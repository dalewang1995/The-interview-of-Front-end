# 闭包

1. 闭包定义：可以访问自由变量的函数，闭包构成的条件=函数+函数可以访问自由变量

   * 自由变量：非当前函数的参数、非当前函数的局部变量
   * 理论角度：所有JavaScript中的函数都为闭包
   * 实践角度：函数创建的上下文已经销毁，但函数依然存在，能够访问自由变量

2. 闭包的应用：保存自己的私有变量，提供接口 get 或 set 给外部调用，但外部不能直接访问该变量

3. 闭包缺点：内存常驻，容易内存泄漏

4. 闭包的基本模型：

   * 对象模式

     函数内部定义一个对象，对象中绑定多个函数，例如：

     ```javascript
     function createPerson() {
       var name = '';
       return {
         getName: function() {
           return name;
         },
         setName: function(val) {
           name = val;
         }
       };
     }
     var person = createPerson();
     person.setName('jack');
     person.getName(); // jack
     ```

   * 函数模式

     函数内部定义一个新函数，返回新函数，用新函数获得函数的内部数据，例如：

     ```javascript
     function foo() {
       var num = Math.random();
       function func() {
         return num;
       }
       return func;
     }
     
     var f = foo();
     var num1 = f();
     var num2 = f();
     ```

   * 沙箱模式

     沙箱模式是一个子调用函数，例如 jQuery：

     ```javascript
     (function() {
       var jQuery = function() {
         jQuery.show = function {console.log(1);}
         window.jQuery = window.$ = jQuery;
       };
     })();
     
     $.show(); // 1
     ```

5. 面试题

   ```javascript
   let res = []
   
   for(let i = 0; i < 3; i++) {
     res[i] = function() {
       console.log(i)
     }
   }
   
   res[0]()
   res[1]()
   res[2]()
   // 打印结果都为3，因为res数组中的函数并没有保存i的引用，当打印时需要根据执行链向上寻找，找到的是3
   ```

   改成闭包后

   ```javascript
   let res = []
   
   for(let i = 0; i < 3; i++) {
     res[i] = (function(i) {
       return function() {
         console.log(i)
       }
     })(i)
   }
   
   res[0]() // 0
   res[1]() // 1
   res[2]() // 2
   // 闭包中保存了自由变量的引用，就不需要再根据执行链向上寻找了
   ```

# 箭头函数与普通函数的区别

箭头函数比普通函数表达式更短，并且不能绑定自己的this、arguments、super和new.target，箭头函数适用于非方法函数，并且不能被当作构造函数

* 箭头函数没有this，需要通过作用域链去查找this的指向
* 箭头函数没有arguments
* 箭头函数不是构造函数，不可以new去调用，也没有new.target
* 箭头函数没有原型，不能调用super()

# 手写克隆函数

```javascript
function deepClone(obj) {
	// 处理基本数据类型、undefined和null
  if(!obj || typeof obj !== 'object') {
    return obj
  }

  if(Object.toString.call(obj) === '[object Date]') {
    return new Date(obj.getTime())
  }
  
  if(Object.toString.call(obj) === '[object RegExp]') {
    return obj.toString()
  }
  
  let res = {}
  if(Array.isArray(obj)) {
    res = []
  }
  
  for(let key in obj) {
    if(obj.hasOwnProperty(key)) {
      const val = obj[key]
      
      if(typeof val === 'object') {
        res[key] = cloneObj(val)
      } else {
        res[key] = val
      }
    }
  }
  return res
}
```

# call、apply和bind的实现原理

1. call函数

   * 定义：call函数是在Function的原型对象上实现的，用来绑定一个函数的执行上下文，可以传递若干参数

   * 模拟实现：

     ```javascript
     Function.prototype.call = function(context) {
       // 过滤null和undefined
       context = context === null || context === undefined ? window : Object(context) 
       // 绑定当前要执行的函数
       context.fn = this
       let args = Array.prototype.splice.call(arguments, 1)
       
       let res = context.fn(...args)
       delete context.fn
       return res
     }
     ```

2. apply函数

   * 定义：apply函数是在Function的原型对象上实现的，用来绑定一个函数的执行上下文，用数组来作为触发函数的参数

   * 模拟实现：

     ```javascript
     Function.prototype.apply = function(context, args) {
     	// 过滤null和undefined
       context = context === null || context === undefined ? window : Object(context) 
       args = args || []
       // 绑定当前要执行的函数
       context.fn = this
       
       let res = context.fn(...args)
       delete context.fn
       return res
     }
     ```

3. bind函数

   * 定义：bind函数是在Function的原型对象上实现的，bind方法会创建一个新函数，当这个新函数被调用时，bind的第一个参数是它的执行上下文this，之后的参数是它的调用参数

   * 模拟实现：

     ```javascript
     Function.prototype.bind(context) {
       let self = this
       let args = Array.prototype.plice.call(arguments, 1)
       // 用一个空函数来做中转赋值
       let noop = function() {}
       let fBOUND = function() {
         let bindArgs = Array.prototype.splice.call(arguments)
         return self.apply(this instanceof noop ? this : context, args.concat(bindArgs))
       }
       
       fNOP.prototype = this.prototype
       fBOUND.prototype = new fNOP()
       return fBOUND
     }
     ```


# 实现add(1)(2)最后返回3

```javascript
function add(num1) {
    return function(num2) {
        return num1 + num2;
    }
}
```

# 实现add(1)(2)(3)(4)最后返回10

考察点：闭包、函数柯里化、console.log(function)调用function.toString()方法

```javascript
function add(num) {
  let res = num
  let fn = function(val) {
    res = res + val
    return fn
  }
  fn.toString = function() {
    return res
  }
  return fn
}
```

# 手写数组去重

```javascript
function unique(nums) {
  if(!nums || nums.length === 0) {
    return []
  }
  if(nums.length === 1) {
    return nums
  }
  
  let map = Object.create(null)
  let res = []
  
  nums.forEach((num, index) => {
    if(typeof map[num] === 'undefined') {
      res.push(num)
      map[num] = num
    }
  })
  
  return res
}
```

# 实现一个函数将URL中的参数解析成JSON对象

```javascript
function parseQueryToJSON(url) {
  if(!url || url.indexOf('?') === -1) {
    return null
  }
  
  url = url.substring(url.indexOf('?') + 1)
  const objStr = decodeURIComponent(url).replace(/"/g, '\\"').replace(/=/g, '":"').replace(/&/g, '","')
  const json = JSON.parse('{"'+ objStr +'"}')
  return json
}
```

# 去除字符串前后的空格

```javascript
function trim(str) {
  return str.replace(/(^\s*)|(\s*$)/g, '');
}
```

# 数组扁平化并排序

```javascript
let arr = [1, 3, 4, [1, 2, [3, 4], 1], 1, 3, [2, 5]]
function flatArr(arr) {
  return arr.toString().split(',').sort((a, b) => {a - b}).map((item) => {
    return parseInt(item)
  })
}

function flatArr(arr) {
  return Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {a - b}).map((item) => {
    return parseInt(item)
  })
}
```

# 生成指定范围的随机数

```javascript
function getRandom(n, m) {
  return Math.floor(Math.random() * (m - n + 1) * n)
}
```

