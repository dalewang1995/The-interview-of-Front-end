# 闭包

1. 闭包定义：可以访问自由变量的函数，闭包构成的条件=函数+函数可以访问自由变量

   * 自由变量：非当前函数的参数、非当前函数的局部变量
   * 理论角度：所有JavaScript中的函数都为闭包
   * 实践角度：函数创建的上下文已经销毁，但函数依然存在，能够访问自由变量

2. 闭包的应用：保存自己的私有变量，提供接口 get 或 set 给外部调用，但外部不能直接访问该变量

3. 闭包缺点：内存常驻，容易内存泄漏

4. 闭包的基本模型：

   * 对象模式

     函数内部定义一个对象，对象中绑定多个函数，例如：

     ```javascript
     function createPerson() {
       var name = '';
       return {
         getName: function() {
           return name;
         },
         setName: function(val) {
           name = val;
         }
       };
     }
     var person = createPerson();
     person.setName('jack');
     person.getName(); // jack
     ```

   * 函数模式

     函数内部定义一个新函数，返回新函数，用新函数获得函数的内部数据，例如：

     ```javascript
     function foo() {
       var num = Math.random();
       function func() {
         return num;
       }
       return func;
     }
     
     var f = foo();
     var num1 = f();
     var num2 = f();
     ```

   * 沙箱模式

     沙箱模式是一个子调用函数，例如 jQuery：

     ```javascript
     (function() {
       var jQuery = function() {
         jQuery.show = function {console.log(1);}
         window.jQuery = window.$ = jQuery;
       };
     })();
     
     $.show(); // 1
     ```

5. 面试题

   ```javascript
   let res = []
   
   for(let i = 0; i < 3; i++) {
     res[i] = function() {
       console.log(i)
     }
   }
   
   res[0]()
   res[1]()
   res[2]()
   // 打印结果都为3，因为res数组中的函数并没有保存i的引用，当打印时需要根据执行链向上寻找，找到的是3
   ```

   改成闭包后

   ```javascript
   let res = []
   
   for(let i = 0; i < 3; i++) {
     res[i] = (function(i) {
       return function() {
         console.log(i)
       }
     })(i)
   }
   
   res[0]() // 0
   res[1]() // 1
   res[2]() // 2
   // 闭包中保存了自由变量的引用，就不需要再根据执行链向上寻找了
   ```

# 箭头函数与普通函数的区别

箭头函数比普通函数表达式更短，并且不能绑定自己的this、arguments、super和new.target，箭头函数适用于非方法函数，并且不能被当作构造函数

* 箭头函数没有this，需要通过作用域链去查找this的指向
* 箭头函数没有arguments
* 箭头函数不是构造函数，不可以new去调用，也没有new.target
* 箭头函数没有原型，不能调用super()

# 手写克隆函数

```javascript
function deepClone(obj) {
	// 处理基本数据类型、undefined和null
  if(!obj || typeof obj !== 'object') {
    return obj
  }

  if(Object.toString.call(obj) === '[object Date]') {
    return new Date(obj.getTime())
  }
  
  if(Object.toString.call(obj) === '[object RegExp]') {
    return obj.toString()
  }
  
  let res = {}
  if(Array.isArray(obj)) {
    res = []
  }
  
  for(let key in obj) {
    if(obj.hasOwnProperty(key)) {
      const val = obj[key]
      
      if(typeof val === 'object') {
        res[key] = cloneObj(val)
      } else {
        res[key] = val
      }
    }
  }
  return res
}
```

