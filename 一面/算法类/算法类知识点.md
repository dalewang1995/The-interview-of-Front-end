# 时间复杂度

评估程序执行所需要的时间

大O表示法O(f(n))，其中f(n)的值可为1、n、logn、n、n^2等。所以我们将 O(1)、O(n)、O(logn)、O(n^2)成为常数阶、线性阶、对数阶、平方阶。

常见时间复杂度比较：O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)

# 空间复杂度

评估程序执行所需要的存储空间

# 位运算

* 算数左移：将二进制向左移动指定位数，例如：10 << 1 为20 可推导公式 a*(2^b)
* 算数右移：将二进制向右移动指定位数，例如：13 >> 1 为6 可推导公式 a/(2^b)
* 按位操作：将二进制按位与、按位或、按位异或

# 数组

* 数组的创建：

  * 一维数组：`const arr = []` 或`const arr = new Array(5).fill(0)`

  * 二维数组：

    ```javascript
    const arr = []
    for(let i = 0; i < arr.length; i++) {
      arr[i] = []
    }
    ```

* 数组的遍历：for（性能最快）、forEach（不能被return终止）、map
* 数组增加元素的三种方法：
  * push：添加到数组尾部`arr.push(1)`
  * splice：添加到数组任意位置`arr.splice(1, 0, 2)`
  * unshift：添加到数组头部`arr.unshift(1)`
*  数组删除元素的三种方法：
  * pop：删除数组尾部元素`arr.pop()`
  * shift：删除数组头部元素`arr.shift()`
  * splice：删除数组任意位置元素`arr.splice(0, 1)`

>  增删元素效率低，访问效率高

# 栈和队列

* 栈：使用`push()`和`pop()`完成增删的数组，先进后出的数据结构，想像成手枪的弹夹，只允许从尾部添加或删除元素
* 队列：使用`push()`和`shift()`完成增删的数组，先进先出的数据结构，想像成排队取餐，只允许从尾部添加元素，只允许从头部删除元素

# 链表

与数组类似的数据结构，属于有序列表，都是线性结构，内部的元素成为节点，每个节点都保存着下一节点或上一节点的引用。链表在内存中与数组不同，数组是一段连续的内存，而链表在内存中则是分散的

* 创建：

  ```javascript
  function ListNode(val) {
    this.val = val
    this.next = null
  }
  const node = new ListNode(1)
  node.next = new ListNode(2)
  ```

* 添加元素：

  ```javascript
  const node1 = new ListNode(1)
  const node3 = new ListNode(3)
  node1.next = node3
  // 添加node2
  const node2 = new ListNode(2)
  node2.next = node1.next
  node1.next = node2
  ```

* 删除元素：

  ```javascript
  const node1 = new ListNode(1)
  const node2 = new ListNode(2)
  const node3 = new ListNode(3)
  node1.next = node2
  node2.next = node3
  // 删除node2
  const target = node2.next
  node1.next = target.next
  ```

> 增删效率高，访问元素效率低

# 二叉树

* 定义：二叉树是满足一下条件的树形结构：
  * 可以作为一颗空树存在，没有根节点
  * 如果不是空树，则必须有左子树、根节点和右子树组成，且左右子树均为二叉树

* 二叉树的创建：

  ```javascript
  function TreeNode(val) {
    this.val = val
    this.left = null
    this.right = null
  }
  const treeNode = new TreeNode(1)
  ```

* 二叉树的遍历

  * 先序遍历、中序遍历、后序遍历：这三种遍历可以基于递归实现，区别在于根节点在遍历中的位置，先序就是指先遍历根节点，依次类推

    ```javascript
    // 先序遍历
    function preOrder(root) {
      if(!root) {
        return null
      }
      
      console.log('先序遍历', root.val)
      preOrder(root.left)
      preOrder(root.rigth)
    }
    // 中序遍历
    function inOrder(root) {
      if(!root) {
        return null
      }
      
      inOrder(root.left)
      console.log('中序遍历', root.val)
      inOrder(root.rigth)
    }
    // 后序遍历
    function postOrder(root) {
      if(!root) {
        return null
      }
      
      postOrder(root.left)
      postOrder(root.rigth)
      console.log('后序遍历', root.val)
    }
    ```

  * 层次遍历：

# 排序

1. 快速排序：

   首先找到数组中的基准点，并获取基准点的值，然后声明两个数组区间，遍历数组，将比基准点小的值放入左区间，将比基准点大的值放入右区间，依次递归，得到排序后的数组。（平均O(nlgn)，最坏O(n^2)）

2. 选择排序：

   首先找到数组中的起点数，默认为第一个数，依次遍历数组，如果比起点数小则交换，保证起点数永远是最小的数，依次遍历，得到有序数组。

3. 希尔排序：

   先将整个待排序的数据序列分成若干个待排序的子序列直接进行插入排序，等到整个序列基本有序时，再对全体序列进行插入排序，因为插入排序对有序序列执行的效率是最高的。

4. 插入排序：

   通过构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。从后向前扫描过程中，需要将已排序元素逐渐向后挪位，为新元素提供插入空间。

5. JS系统自带排序：数组长度大于10会使用快排，否则会使用插入排序

> ```
> arr.sort()` 等同于 `arr.sort( (a , b) => a.charCodeAt() - b.charCodeAt() )
> ```

# 递归。

* 斐波那契数列：

   ```javascript
  function fib(n){
    if(n < 2 && n >= 0) {
      return n
    }
    return fib(n - 1) + fib(n - 2)
  }
  ```

* 斐波那契数列优化：

  ```javascript
  let temp = []
  function fib(n){
    if(n < 2 && n >= 0) {
      return n
    }
    if(temp[n]) {
      return temp[n]
    } 
    const res = fib(n - 1) + fib(n - 2)
    temp[n] = res
    return temp[n]
  }
  ```

*  二分查找（有序数组）：

   ```javascript
   function binarySearch(arr, target, start, end){
     if(start > end) {
       return -1
     }
    
     let startIndex = start || 0
     let endIndex = end || arr.length - 1
     let middle = (startIndex + middle) >> 1
    
     if(target > arr[middle]) {
       return binarySearch(arr, target, middle + 1, endIndex)
     }
     if(target < arr[middle]) {
       return binarySearch(arr, target, startIndex, middle - 1)
     }
     return middle
   }
   
   // 非递归
   function binarySearch(arr, target){
     if(!arr || arr.length === 0) {
       return -1
     }
     
     if(arr.length === 1) {
       return arr[0] === target ? 0 : -1
     }
     let lowIndex = 0
     let highIndex = arr.length - 1
     
     while(lowIndex < highIndex) {
       const midIndex = (lowIndex + highIndex) >> 1
       const midVal = arr[midIndex]
       
       if(midVal < target) {
         lowIndex = midIndex + 1
       } else if (midVal > target) {
         highIndex = midIndex - 1
       } else {
         return midIndex
       }
     }
     return -1
   }
   
   ```

# 堆栈、队列。

1. 堆栈：只能在一端添加或者删除数据，遵循先进后出原则，类似手枪弹夹。
2. 队列：在一端添加数据，在另一端删除数据，遵循先进先出原则，类似生活中的排队。

# 树

# 动态规划

动态规划的核心思路：

* 自底向上分解子问题
* 通过变量存储已经计算过的解

应用：

* 斐波那契数列：

  ```javascript
  function fib(n){
    let arr = new Array(n + 1).fill(0)
    arr[0] = 0
    arr[1] = 1
    
    for(let i = 2; i < arr.length; i++){
      arr[i] = arr[i - 1] + arr[i - 2]
    }
    
    return arr[n]
  }
  ```
