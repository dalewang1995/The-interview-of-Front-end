# 什么是同源策略及限制。

1. 同源策略限制从一个源（协议+域名+端口 ）加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的关键安全机制

2. 限制：Cookie、LocalStorage无法读取，DOM无法获得，AJAX不能发送。

# 前后端如何通信。

1. AJAX
2. WebSocket
3. CORS

# 如何创建Ajax。

```
var xhr = XMLHttpRequest ? new XMLHttpRequest : new ActiveXObject('Microsoft.XMLHTTP');
xhr.onload = function() {
  if((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
    console.log(xhr.responseText);
  }
}
xhr.open('GET', 'http://localhost:8080/test.action', true);
xhr.send(null);
xhr.error = function() {
  console.error('error');
}
```

# 跨域通信的几种方式。

同源策略只是限制了跨域的AJAX请求。

1. JSONP 利用script标签的异步加载实现。只支持GET请求。

2. Hash iframe通信

3. postMessage H5新提供API

4. WebSocket

  ```
  var ws = new WebSocket('wss:http://test.com');
  ws.send('hello');
  var data = new ArrayBuffer(10000);
  ws.send(data);

  // 检查数据是否发送完毕
  if(socket.bufferedAmount === 0) {
  // success
  }else{

  }
  ```

5. CORS 跨域资源共享，目前所有的浏览器（IE10+）均支持CORS，实现CORS的关键在服务器，需要实现CORS接口。 浏览器直接发出CORS请求会在请求头部中增加Origin字段。 服务器需要设置响应头Access-Control-Allow-Origin: *

6. nginx反向代理，同源策略是浏览器的一种安全机制，服务端不受同源策略影响

7. location.hash

# CORS机制

* 需要浏览器和服务器同时支持

* 浏览器将CORS请求分为两类：

  * 简单请求：请求方法为GET、POST、HEAD，并且请求头不能超出以下几种：Accept、Accept-Language、Content-Language、Last-Event-ID和Content-Type只能为：application/x-www-form-urlencoded、multipart/form-data、text/plain

  * 非简单请求：请求方法为PUT或DELETE，或者请求头Content-Type为application/json

* 对于简单请求：

  * 浏览器直接发出CORS请求，会在请求头中增加Origin字段，用来标识请求来自哪个源

  * 如果指定的Origin，不在服务器的许可范围内，服务器会返回一个正常的HTTP响应（状态码有可能是200），但是响应头里没有Access-Control-Allow-Origin字段，浏览器发现缺少Access-Control-Allow-Origin，就会抛出一个错误（可以被XMLHttpRequest的onerror捕获到）

  * 如果指定的Origin，在服务器的许可范围内，服务器的响应头中会有增加三个字段：Access-Control-Allow-Origin、Access-Control-Allow-Credentials和Access-Control-Expose-Headers

* 对于非简单请求：
  * 浏览器会在正式通信之前先发出Options预检请求，预检请求的请求头会增加Origin、Access-Control-Request-Method和Access-Control-Request-Headers这三个字段
  * 如果预检请求失败，会返回一个正常的HTTP请求，但是没有任何CORS相关字段，浏览器发现没有CORS相关字段，就会抛出一个错误（可以被XMLHttpRequest的onerror捕获到）
  * 预检请求成功，就会跟简单请求一样来通信

* Options请求优化
  * 将非简单请求变为简单请求
  * 设置Access-Control-Max-Age字段，浏览器会根据这个请求头字段来判断OPTIONS预检请求的响应结果要缓存多久（对于相同请求来说，在指定时间内，只会触发一次预检请求）

# JSBridge原理

* JSBridge介绍：JSBridge是用来给JavaScript提供调用Native功能的接口，它的核心是构建Natvie端和非Native端**双向消息通信通道**

* JSBridge的应用场景：

  * 基于Web UI的Hybrid构建方案，例如：微信浏览器
  * 基于非Web UI但业务逻辑基于JavaScript的构建方案，例如RN

  > 各端小程序的实现方案，是基于Web UI，但是为了优化体验，Web UI的渲染和JavaScript的执行是隔离开的，因此小程序的解决方案基于上面这两种之间。

* JSBridge的通信原理：

  * JavaScript调用Native接口：
    * Api注入：通过WebView提供的接口，向JavaScript的context(window)中注入对象或者方法，浏览器端通过window上的对象或者方法直接调用（postmessage方法）
    * URL Scheme解析：灵活性差，会创建请求耗时，但兼容低版本系统，属于降级方案
  * Natvie调用JavaScript方法：JavaScript方法必须在window对象上，Native通过WebView直接调用相应的api来执行JavaScript字符串代码。
  * JavaScript调用Native接口之后的回调函数执行方式：类似JSONP的回调机制，回调函数设置唯一标识（可以是对象的key或数组的索引），并把唯一标识传递给Native端，Native执行回调时把唯一标识透传回来由JavaScript端寻找对应的回调执行

* JSBridge如何引用：

  * Native端注入：注入时机需与JavaScript端协商一致，注入失败需要重试机制，版本可控
  * JavaScript端引用：注入时机可控，版本维护成本高