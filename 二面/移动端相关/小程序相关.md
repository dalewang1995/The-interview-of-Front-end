# 小程序架构原理

小程序采用双线程架构，渲染层和逻辑层分别交给两个独立的线程去处理，保证页面渲染、逻辑执行的流畅性，同时也隔离了风险（无法操作window对象），视图层和逻辑层通过系统层的JSBridge来通信

* View视图层渲染：创建WebView线程来渲染页面，在启动时会预先加载一个WebView，多个界面代表多个WebView线程。
* App Service逻辑层执行：创建一个独立的JSCore线程来执行处理逻辑，提供一个纯沙盒环境来执行JS，没有任何浏览器相关的接口，逻辑层发送请求也由Native层做转发
* 双线程通信：渲染层把WXML转换成对应的JS对象（Virtual DOM），在逻辑层发成变更时，通过宿主环境提供的setData把数据从逻辑层传递到Native，在转发到渲染层，渲染层对比差异，将Virtual DOM映射要DOM结构上
* 小程序基础库：基于JS编写，分别被注入到逻辑层和渲染层执行，它内置在微信客户端内，由Exparser框架进行管理
  * 渲染层基础库：基于Exparser框架提供各类内置组件来渲染页面
  * 逻辑层基础库：提供各类api来处理逻辑，处理数据绑定，事件系统，通信系统等

> 双线程设计主要是为了提高管控安全，避免DOM操作，可以有效的避免XSS注入

# 小程序的启动机制

* 冷启动：用户首次打开小程序，或者小程序被微信销毁后重新打开，需要重新加载启动（onLaunch->onShow），启动是会从CND下载小程序的完整包

* 热启动：用户已经打开过小程序，在指定时间内再次打开小程序，此时无需重新启动，只是将小程序从后台切换到前台（onShow）

# 小程序的销毁机制

* 主动销毁：小程序没有重启的概念，当小程序进入后台之后，会维持一段时间的运行状态，在超过指定时间之后（一般是5分钟）会被微信主动销毁
* 被动销毁：当小程序在运行过程中在短时间内（一般是5s）连续收到两次以上的内存告警，小程序将会被微信销毁

# 小程序的更新机制

小程序冷启动（重新加载启动）时如果发现有新版本，将会异步下载版本的代码包，并同时将客户端本地的包进行启动，这时最新的代码实际上没有被加载，需要等到小程序下一个冷启动时才会加载，如果需要马上版本更新，可以使用wx.getUpdateManager来手动处理

# 小程序性能优化

* 避免频繁的setData，避免大数据量的setData，只设置UI相关的字段
* 控制主包大小1MB左右，采取分包预加载
* 去掉不必要事件绑定，避免data-*绑定过多的值
* 微信后台设置数据预拉取，周期性更新
* 避免在生命周期函数中采用`Sync`结尾的同步API

# 小程序setData机制

setData是异步的，视图层和逻辑层的数据传输，实际上是通过两边提供的evaluateJavaScript来实现的，用户传输的数据，需要将其转换为字符串的形式再进行传递，同时把转换后的数据内容拼接成JS代码，再通过执行JS脚本的形式传递到两边的环境

# 多端小程序框架对比

多端框架基本实现原理：以JavaScript为基础选定一个DSL框架，以这个DSL框架为基准在各端分别编译出不同的代码，各端分别有一个运行时框架或兼容组件库来保证代码正确运行

* Taro：React语法、集成了ESLint语法检查、支持TS、支持六端、具有跨端组件库，具有Taro-cli可以转译代码（接入成本小）、支持MobX等多种状态管理工具
* WePY：类Vue语法、支持TS
* uni-app：Vue语法，具有自研IDE、支持TS、支持六端
* mp-vue（美团）：Vue语法、支持TS
* chameleon（滴滴）：类Vue、不支持TS

# Taro框架实现原理

Taro框架实现分为两部分：

* 编译框架：前置编译框架，使用Babel一系列模块来完成代码的编译，主要分为以下几个方面
  * 使用Babylon解析代码生成AST，使用Babel-traverse遍历AST语法树，使用Babel-types工具库来完成对AST的增删改查，最终生成目标代码
  * 将JSX文件转换为.wxml模版、生成小程序的配置文件、页面等组件代码
  * 将render函数重命名为_createData，一个创建数据的方法，JSX引用的数据都将被创建然后放到小程序的data中
* 运行时框架：负责把编译后的代码运行在本不能运行的对应环境中，相当于浏览器的polyfill，并抹平平台差异，采用微信小程序的组件库和api作为运行时的标准
  * 标准运行时框架：@taro/taro
  * 标准基础组件库：@tarojs/components
  * 标准端能力Api：@taro/taro
  * createApp、createPage、createComponent这三个方法在编译时注入到代码中，在运行时创建程序、页面和组件
  * 运行时将setState转换成setData、生命周期转换、事件处理函数转换、api进行Promise化

