# 设计模式

核心思想：封装变化，将变与不变分离，确保变化部分灵活，不变部分稳定

* 创建型
  * 简单工厂模式：将创建对象的过程单独封装，目的是为了实现无脑传参，有构造函数的地方就应该想到工厂模式
  * 抽象工厂模式：开放封闭原则的特征体现，抽象类的实际应用（抽象工厂、具体工厂、抽象产品、具体产品）
  * 单例模式：保证一个类只有一个实例，并且提供一个访问它的全局访问点
  * 原型模式：基于原型链的继承，编程范式，Object.create()是原型模式的天然实现
* 结构型
* 行为型

# SOLID原则

* 单一功能原则
* 开放封闭原则：可以扩展，但不可以修改
* 里氏替换原则
* 接口隔离原则
* 依赖反转原则

# 发布-订阅模式实现

```javascript
/**
 * 发布-订阅事件处理器
 */
class EventEmitter {
  constructor() {
    this.eventMap = Object.create(null)
  }
  /**
   * 事件订阅
   * @param {String} eventName 事件名
   * @param {Function} func 执行函数
   */
  on(eventName, func) {
    const events = this.eventMap[eventName]
    if (Array.isArray(events) && typeof func === 'function') {
      this.eventMap[eventName].push(func)
    } else {
      this.eventMap[eventName] = [func]
    }
  }
  /**
   * 事件触发
   * @param {String} eventName 事件名
   */
  emit(eventName) {
    const events = this.eventMap[eventName]
    const args = Array.prototype.slice.call(arguments, 1)
    const that = this
    if (Array.isArray(events)) {
      events.forEach((event) => {
        event.apply(that, args)
      })
    }
  }
  /**
   * 事件移除
   * @param {String} eventName 事件名
   * @param {Function} func 执行函数
   */
  off(eventName, func) {
    const events = this.eventMap[eventName]
    if (Array.isArray(events) && typeof func === 'function') {
      this.eventMap[eventName] = events.filter((event) => {
        return event !== func
      })
    }
  }
  /**
   * 事件一次订阅
   * @param {String} eventName 事件名
   * @param {Function} func 执行函数
   */
  once(eventName, func) {
    const that = this
    function newFunc() {
      const args = Array.prototype.slice.call(arguments, 0)
      func.apply(that, args)
      this.off('eventName', newFunc)
    }
    this.on(eventName, newFunc)
  }
}

export default EventEmitter
```

# 单例模式实现Storage

```javascript
class Storage {
  static getInstance() {
    if(!Storage.instance) {
      Storage.instance = new Storage()
    }
    return Storage.instance
  }
  getItem(key) {
    return localStorage.getItem(key)
  }
  setItem(key, value) {
    return localStorage.setItem(key, value)
  }
}
```

