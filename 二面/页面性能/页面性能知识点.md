# 提升页面性能的方法有哪些。

1. 资源压缩合并，减少 HTTP 请求
2. 非核心代码异步加载
3. 利用浏览器缓存
4. 使用 CDN
5. 预解析 DNS

  ```html
  <!-- https强制开启a标签DNS预解析 -->
  <meta http-equiv="x-dns-prefetch-control" content="on">

  <!-- 开启DNS预解析 -->
  <link rel="dns-prefetch" href="//host_name_to_prefetch.com">
  ```

# 异步加载 JS 的三种方式与区别。

1. 异步加载的方式：动态脚本加载，defer 属性，async 属性
2. 异步加载的区别：

  defer 是在 HTML 解析完之后才执行，如果有多个，则按照加载顺序执行。

  async 是在加载完之后立即执行，如果有多个，执行顺序和加载顺序无关。

# 浏览器缓存

* Memory Cache：内存中的缓存，命中优先级最高，浏览器会秉承“节约原则”将一些小文件存到内存缓存中，例如Base64的图片文件，对于比较大的文件会放入磁盘中
* HTTP Cache：
  * 强缓存：不与服务器发生通信，HTTP状态码为200，优先命中强缓存
    * Expires：服务器在响应头设置的缓存过期时间，用于和浏览器本地时间对比（依赖浏览器本地时间，有缺陷），现在使用Expires更多的是为了向下兼容
    * Cache-Control：HTTP1.1新增，通过max-age=多少秒来设置缓存有效期，优先级高。no-store不使用任何缓存，no-cache询问浏览器，走协商缓存
  * 协商缓存：需要和服务器通信，HTTP状态码304
    * Last-Modified：一个时间戳，会在首次请求的响应头中返回，之后会在每次请求头中带上If-Modified-Since的一个时间戳，服务器会比较两个时间戳，判断是否执行缓存（两个问题：改动文件但没有变化、改动文件过快会导致计算不准）
    * Etag：对Last-Modified的补充，服务器为每个资源生成的标识字符串，优先级高。首次请求的响应头中获取，并在之后的每次请求头中带上If-None-Match供服务器来对比
* Service Worker Cache：Service Worker独立线程实现的缓存，缓存命中优先级在Memory Cache和HTTP Cache之后（必须是HTTPS协议）
* Push Cache：HTTP2新特性，服务端主动推送缓存，session级别的缓存，缓存命中优先级最低
